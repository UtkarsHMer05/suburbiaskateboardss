/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
This comment indicates that this file structure was initially created by a tool
that converts 3D GLTF models into React components.
*/

// Import necessary libraries and hooks for 3D rendering and animations
import * as THREE from "three"; // The main 3D library that powers the rendering
import { useEffect, useMemo, useRef } from "react"; // React hooks for managing component lifecycle and optimization
import { useGLTF, useTexture } from "@react-three/drei"; // Helpful utilities for loading 3D models and textures
import { GLTF } from "three-stdlib"; // Type definitions for 3D models
import { useFrame } from "@react-three/fiber"; // Hook that runs on every animation frame
import gsap from "gsap"; // Animation library for smooth transitions

/**
 * Type definition for the Skateboard component's props:
 * • wheelTextureURLs: Array of image URLs for wheel textures the user can choose from
 * • wheelTextureURL: The currently selected wheel texture
 * • deckTextureURLs: Array of image URLs for skateboard deck designs
 * • deckTextureURL: The currently selected deck design texture
 * • truckColor: Color for the metal trucks (the parts that hold the wheels)
 * • boltColor: Color for the small bolts that attach trucks to the deck
 * • constantWheelSpin: Optional boolean to make wheels constantly rotate
 * • pose: Optional setting to display the board upright or on its side
 */
type SkateboardProps = {
  wheelTextureURLs: string[];
  wheelTextureURL: string;
  deckTextureURLs: string[];
  deckTextureURL: string;
  truckColor: string;
  boltColor: string;
  constantWheelSpin?: boolean;
  pose?: "upright" | "side";
};

/**
 * Type definition that extends the GLTF model type with our specific
 * skateboard model parts. This helps TypeScript understand the structure
 * of our 3D model and its various mesh components.
 */
type GLTFResult = GLTF & {
  nodes: {
    GripTape: THREE.Mesh; // The rough top surface of the skateboard
    Wheel1: THREE.Mesh; // Front-right wheel
    Wheel2: THREE.Mesh; // Front-left wheel
    Deck: THREE.Mesh; // The wooden board part
    Wheel4: THREE.Mesh; // Back-left wheel
    Bolts: THREE.Mesh; // The metal bolts that attach components
    Wheel3: THREE.Mesh; // Back-right wheel
    Baseplates: THREE.Mesh; // The metal plates that attach trucks to deck
    Truck1: THREE.Mesh; // Back truck assembly
    Truck2: THREE.Mesh; // Front truck assembly
  };
  materials: object; // Original materials from the model (not used here)
};

/**
 * The Skateboard component:
 * This is a 3D model of a skateboard that can be customized with different
 * textures, colors, and poses. It's built using React Three Fiber (R3F).
 */
export function Skateboard({
  wheelTextureURL, // Currently selected wheel texture
  wheelTextureURLs, // Array of available wheel textures
  deckTextureURL, // Currently selected deck design
  deckTextureURLs, // Array of available deck designs
  truckColor, // Color for the metal trucks
  boltColor, // Color for the bolts
  constantWheelSpin = false, // Whether wheels should spin constantly
  pose = "upright", // Default pose is standing upright
}: SkateboardProps) {
  // Create a reference to store all wheel objects for animation
  const wheelRefs = useRef<THREE.Object3D[]>([]);

  // Load the 3D skateboard model from a GLTF file
  const { nodes } = useGLTF("/skateboard.gltf") as unknown as GLTFResult;

  // WHEEL TEXTURES
  // Load all wheel texture images and set up proper texture settings
  const wheelTextures = useTexture(wheelTextureURLs);
  wheelTextures.forEach((texture) => {
    texture.flipY = false; // Prevent textures from being flipped
    texture.colorSpace = THREE.SRGBColorSpace; // Use correct color space for web
  });
  // Find which wheel texture is currently selected
  const wheelTextureIndex = wheelTextureURLs.findIndex(
    (url) => url === wheelTextureURL
  );
  // Get the actual texture object for the selected wheel texture
  const wheelTexture = wheelTextures[wheelTextureIndex];

  // DECK TEXTURES
  // Similar to wheel textures, load all deck design textures
  const deckTextures = useTexture(deckTextureURLs);
  deckTextures.forEach((texture) => {
    texture.flipY = false;
    texture.colorSpace = THREE.SRGBColorSpace;
  });
  // Find which deck texture is currently selected
  const deckTextureIndex = deckTextureURLs.findIndex(
    (url) => url === deckTextureURL
  );
  // Get the actual texture object for the selected deck texture
  const deckTexture = deckTextures[deckTextureIndex];

  // Load grip tape textures (the rough surface on top of the skateboard)
  const gripTapeDiffuse = useTexture("/skateboard/griptape-diffuse.webp");
  const gripTapeRoughness = useTexture("/skateboard/griptape-roughness.webp");

  /**
   * Create a material for the grip tape using the loaded textures.
   * useMemo ensures this expensive operation only happens when dependencies change.
   *
   * The material uses:
   * • map: The basic color/pattern texture
   * • bumpMap: Creates small height variations for a 3D effect
   * • roughnessMap: Controls how light scatters (makes it look rough)
   */
  const gripTapeMaterial = useMemo(() => {
    const material = new THREE.MeshStandardMaterial({
      map: gripTapeDiffuse,
      bumpMap: gripTapeRoughness,
      roughnessMap: gripTapeRoughness,
      bumpScale: 3.5, // How pronounced the bumps are
      roughness: 0.8, // How rough the surface appears
      color: "#555555", // Dark gray base color
    });

    // If texture loaded successfully, set up tiling (repeating pattern)
    if (gripTapeDiffuse) {
      // Make texture repeat instead of stretching
      gripTapeDiffuse.wrapS = THREE.RepeatWrapping;
      gripTapeDiffuse.wrapT = THREE.RepeatWrapping;
      gripTapeDiffuse.repeat.set(9, 9); // Repeat 9 times in each direction
      gripTapeDiffuse.needsUpdate = true; // Tell Three.js to update the texture

      // Same settings for the roughness texture
      gripTapeRoughness.wrapS = THREE.RepeatWrapping;
      gripTapeRoughness.wrapT = THREE.RepeatWrapping;
      gripTapeRoughness.repeat.set(9, 9);
      gripTapeRoughness.needsUpdate = true;

      // Improve texture quality by adding anisotropic filtering
      gripTapeRoughness.anisotropy = 8;
    }

    return material;
  }, [gripTapeDiffuse, gripTapeRoughness]); // Only recreate if these textures change

  /**
   * Create a material for the bolts.
   * Makes them look metallic with the specified color.
   */
  const boltMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: boltColor, // User-selected color
        metalness: 0.5, // How metallic the surface appears (0-1)
        roughness: 0.3, // How smooth/rough the surface is (0-1)
      }),
    [boltColor] // Only recreate when bolt color changes
  );

  // Load a normal map texture for the trucks to add small surface details
  const metalNormal = useTexture("/skateboard/metal-normal.avif");
  metalNormal.wrapS = THREE.RepeatWrapping;
  metalNormal.wrapT = THREE.RepeatWrapping;
  metalNormal.anisotropy = 8; // Improve texture quality
  metalNormal.repeat.set(8, 8); // Repeat the pattern 8 times

  /**
   * Create a material for the trucks (the metal parts that hold the wheels).
   * Uses normal mapping to create the illusion of small surface details.
   */
  const truckMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: truckColor, // User-selected color
        normalMap: metalNormal, // Texture that adds small surface details
        normalScale: new THREE.Vector2(0.3, 0.3), // How intense the details appear
        metalness: 0.8, // Very metallic look
        roughness: 0.25, // Fairly smooth but not completely
      }),
    [truckColor, metalNormal] // Only recreate when these dependencies change
  );

  /**
   * Create a material for the skateboard deck (the wooden board part).
   * Uses the selected deck texture.
   */
  const deckMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: deckTexture, // The selected deck design texture
        roughness: 0.1, // Quite smooth surface
      }),
    [deckTexture] // Only recreate when deck texture changes
  );

  /**
   * Create a material for the wheels.
   * Uses the selected wheel texture.
   */
  const wheelMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: wheelTexture, // The selected wheel texture
        roughness: 0.35, // Medium smoothness
      }),
    [wheelTexture] // Only recreate when wheel texture changes
  );

  /**
   * Function to collect references to all wheel objects.
   * This creates an array of wheel objects that we can animate.
   */
  const addToWheelRefs = (ref: THREE.Object3D | null) => {
    if (ref && !wheelRefs.current.includes(ref)) {
      wheelRefs.current.push(ref);
    }
  };

  /**
   * Animation hook that runs on every frame.
   * If constantWheelSpin is true, it rotates all wheels continuously.
   */
  useFrame(() => {
    if (!wheelRefs.current || !constantWheelSpin) return;
    for (const wheel of wheelRefs.current) {
      wheel.rotation.x += 0.2; // Rotate wheel around X axis
    }
  });

  /**
   * Effect that runs when wheelTextureURL changes or constantWheelSpin changes.
   * If not in constant spin mode, it creates a single rotation animation
   * for the wheels using GSAP.
   */
  useEffect(() => {
    if (!wheelRefs.current || constantWheelSpin) return;
    for (const wheel of wheelRefs.current) {
      gsap.to(wheel.rotation, {
        x: "-=30", // Rotate backward by 30 radians
        duration: 2.5, // Animation takes 2.5 seconds
        ease: "circ.out", // Ease out for a natural slowing down effect
      });
    }
  }, [constantWheelSpin, wheelTextureURL]); // Run when these values change

  /**
   * Define positioning presets for different skateboard poses.
   * This creates an object with rotation and position values for each pose.
   */
  const positions = useMemo(
    () =>
      ({
        upright: {
          rotation: [0, 0, 0], // No rotation (default position)
          position: [0, 0, 0], // No position offset
        },
        side: {
          rotation: [0, 0, Math.PI / 2], // Rotated 90 degrees on Z axis
          position: [0, 0.295, 0], // Shifted up to compensate for rotation
        },
      }) as const,
    [] // This never needs to be recalculated
  );

  return (
    <group
      dispose={null} // Tell Three.js not to dispose resources when unmounting
      rotation={positions[pose].rotation} // Apply rotation based on selected pose
      position={positions[pose].position} // Apply position based on selected pose
    >
      <group name="Scene">
        {/* Grip Tape - The rough black surface on top of the board */}
        <mesh
          name="GripTape"
          castShadow
          receiveShadow
          geometry={nodes.GripTape.geometry} // Use the geometry from the GLTF model
          material={gripTapeMaterial}
          position={[0, 0.286, -0.002]} // Position slightly above the deck
        />

        {/* Wheel1 - Front-right wheel */}
        <mesh
          name="Wheel1"
          castShadow
          receiveShadow
          geometry={nodes.Wheel1.geometry}
          material={wheelMaterial}
          position={[0.238, 0.086, 0.635]} // Position at front-right
          ref={addToWheelRefs} // Add to wheel refs for animation
        />

        {/* Wheel2 - Front-left wheel */}
        <mesh
          name="Wheel2"
          castShadow
          receiveShadow
          geometry={nodes.Wheel2.geometry}
          material={wheelMaterial}
          position={[-0.237, 0.086, 0.635]} // Position at front-left
          ref={addToWheelRefs} // Add to wheel refs for animation
        />

        {/* Deck - The wooden board part with graphics on the bottom */}
        <mesh
          name="Deck"
          castShadow
          receiveShadow
          geometry={nodes.Deck.geometry}
          material={deckMaterial}
          position={[0, 0.271, -0.002]} // Position just below the grip tape
        />

        {/* Wheel3 - Back-right wheel */}
        <mesh
          name="Wheel3"
          castShadow
          receiveShadow
          geometry={nodes.Wheel3.geometry}
          material={wheelMaterial}
          position={[0.237, 0.086, -0.635]} // Position at back-right
          rotation={[Math.PI, 0, Math.PI]} // Rotated to face backward
          ref={addToWheelRefs} // Add to wheel refs for animation
        />

        {/* Wheel4 - Back-left wheel */}
        <mesh
          name="Wheel4"
          castShadow
          receiveShadow
          geometry={nodes.Wheel4.geometry}
          material={wheelMaterial}
          position={[-0.238, 0.086, -0.635]} // Position at back-left
          rotation={[Math.PI, 0, Math.PI]} // Rotated to face backward
          ref={addToWheelRefs} // Add to wheel refs for animation
        />

        {/* Bolts - Small metal parts that attach trucks to the deck */}
        <mesh
          name="Bolts"
          castShadow
          receiveShadow
          geometry={nodes.Bolts.geometry}
          material={boltMaterial}
          position={[0, 0.198, 0]} // Position between deck and trucks
          rotation={[Math.PI, 0, Math.PI]} // Rotated to face down
        />

        {/* Baseplates - The metal plates that attach trucks to the deck */}
        <mesh
          name="Baseplates"
          castShadow
          receiveShadow
          geometry={nodes.Baseplates.geometry}
          material={truckMaterial}
          position={[0, 0.211, 0]} // Position between deck and trucks
        />

        {/* Truck1 - Back truck assembly */}
        <mesh
          name="Truck1"
          castShadow
          receiveShadow
          geometry={nodes.Truck1.geometry}
          material={truckMaterial}
          position={[0, 0.101, -0.617]} // Position at the back
        />

        {/* Truck2 - Front truck assembly */}
        <mesh
          name="Truck2"
          castShadow
          receiveShadow
          geometry={nodes.Truck2.geometry}
          material={truckMaterial}
          position={[0, 0.101, 0.617]} // Position at the front
          rotation={[Math.PI, 0, Math.PI]} // Rotated to face forward
        />
      </group>
    </group>
  );
}

// Preload the skateboard model to improve performance
// This loads the 3D model in the background so it's ready when needed
useGLTF.preload("/skateboard.gltf");
